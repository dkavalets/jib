// define all versioned plugins here and apply in subprojects as necessary without version
plugins {
  id 'com.github.sherter.google-java-format' version '0.8' apply false
  id 'net.ltgt.apt' version '0.19' apply false
  id 'net.ltgt.errorprone' version '0.6' apply false
  id 'net.researchgate.release' version '2.7.0' apply false
  id 'com.gradle.plugin-publish' version '0.9.10' apply false
  id 'com.liferay.maven.plugin.builder' version '1.2.4' apply false
}

import net.ltgt.gradle.errorprone.CheckSeverity

project(':jib-core') {
  apply plugin: 'java-library' // needs to be applied before 'java'
}
subprojects {
  group 'com.google.cloud.tools'

  repositories {
    mavenCentral()
  }

  apply plugin: 'java'
  apply plugin: 'maven'
  apply plugin: 'checkstyle'
  apply plugin: 'com.github.sherter.google-java-format'
  apply plugin: 'net.ltgt.apt'
  apply plugin: 'net.ltgt.errorprone'

  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8
  compileJava.options.encoding = 'UTF-8'

  /* PROJECT DEPENDENCY CONTRAINTS */
  // define all versioned dependencies here and apply in subprojects as necessary without version
  dependencies {
    constraints {
      implementation 'com.google.http-client:google-http-client:1.27.0'
      implementation 'org.apache.commons:commons-compress:1.18'
      implementation 'com.google.guava:guava:27.0.1-jre'
      implementation 'com.fasterxml.jackson.core:jackson-databind:2.9.9'
      implementation 'org.ow2.asm:asm:7.0'

      testImplementation 'junit:junit:4.12'
      testImplementation 'org.mockito:mockito-core:2.23.4'
      testImplementation 'org.slf4j:slf4j-api:1.7.25'
    }
  }
  /* PROJECT DEPENDENCY CONTRAINTS */

  /* NULLAWAY */
  dependencies {
    // NullAway errorprone plugin
    annotationProcessor 'com.uber.nullaway:nullaway:0.6.4'
    errorprone 'com.google.errorprone:error_prone_core:2.3.2'
    // Using github.com/google/error-prone-javac is required when running on
    // JDK 8. Remove when migrating to JDK 11.
    if (System.getProperty("java.version").startsWith("1.8.")) {
      errorproneJavac("com.google.errorprone:javac:9+181-r4173-1")
    }
  }

  // Adds NullAway errorprone checks.
  tasks.withType(JavaCompile) {
    if (!name.toLowerCase().contains("test")) {
      options.errorprone {
        check('NullAway', CheckSeverity.ERROR)
        option('NullAway:ExcludedFieldAnnotations', 'org.apache.maven.plugins.annotations.Component')
        option('NullAway:AnnotatedPackages', 'com.google.cloud.tools')
      }
    }
  }
  /* NULLAWAY */

  /* GOOGLE JAVA FORMAT */
  googleJavaFormat {
    toolVersion = '1.6'
  }
  check.dependsOn verifyGoogleJavaFormat
  /* GOOGLE JAVA FORMAT */

  /* CHECKSTYLE */
  checkstyle {
    toolVersion = '8.18'

    // get the google_checks.xml file from the checkstyle jar and take out the java checks
    def googleChecks = resources.text.fromArchiveEntry(configurations.checkstyle[0], 'google_checks.xml').asString()
    def fileExtensionsBefore = '<property name="fileExtensions" value="java, properties, xml"/>'
    def fileExtensionsAfter = '<property name="fileExtensions" value="properties, xml"/>'
    def googleChecksNoJava = googleChecks.replace(fileExtensionsBefore, fileExtensionsAfter)
    assert !googleChecks.equals(googleChecksNoJava)

    config = resources.text.fromString(googleChecksNoJava)

    maxErrors = 0
    maxWarnings = 0
  }
  /* CHECKSTYLE */

  /* TEST CONFIG */
  tasks.withType(Test) {
    reports.html.setDestination file("${reporting.baseDir}/${name}")
  }

  test {
    testLogging {
      showStandardStreams = true
      exceptionFormat = 'full'
    }
  }
  // jar to export tests classes for import in other project by doing:
  // testCompile project(path:':project-name', configuration:'tests')
  task testJar(type: Jar) {
    from sourceSets.test.output.classesDirs
    classifier = 'tests'
  }
  // to import resources do: sourceSets.test.resources.srcDirs project(':project-name').sourceSets.test.resources

  configurations {
    tests
  }

  artifacts {
    tests testJar
  }
  /* TEST CONFIG */

  /* INTEGRATION TESTS */
  sourceSets {
    integrationTest {
      java.srcDir file('src/integration-test/java')
      resources.srcDir file('src/integration-test/resources')
    }
  }

  configurations {
    integrationTestImplementation.extendsFrom testImplementation
    integrationTestRuntime.extendsFrom testRuntime
  }

  dependencies {
    integrationTestImplementation sourceSets.main.output
    integrationTestImplementation sourceSets.test.output
    integrationTestImplementation configurations.compile
    integrationTestImplementation configurations.testImplementation
    integrationTestImplementation configurations.runtime
    integrationTestImplementation configurations.testRuntime
  }

  // Integration tests must be run explicitly
  task integrationTest(type: Test) {
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    systemProperty '_JIB_DISABLE_USER_AGENT', true
  }
  integrationTest.dependsOn test

  task integrationTestJar(type: Jar) {
    from sourceSets.integrationTest.output.classesDirs
    classifier = 'integration-tests'
  }

  configurations {
    integrationTests
  }

  artifacts {
    integrationTests integrationTestJar
  }
  /* INTEGRATION TESTS */

  /* JAVADOC ENFORCEMENT */
  // Fail build on javadoc warnings
  tasks.withType(Javadoc) {
    options.addBooleanOption('Xwerror', true)
  }
  assemble.dependsOn javadoc
  /* JAVADOC ENFORCEMENT */

  /* OTHER JARS */
  task sourceJar(type: Jar) {
    from sourceSets.main.allJava
    classifier 'sources'
  }

  task javadocJar(type: Jar, dependsOn: javadoc) {
    from javadoc.destinationDir
    classifier 'javadoc'
  }
  /* OTHER JARS */

  /* INCLUDED PROJECT DEPENDENCY HELPER */
  // to keep track of all source projects
  project.ext.sourceProjects = []
  // sourceProject(Project) accepts a project and adds it as a dependency in a special manner:
  // 1. add the project dependency as a "compileOnly" and make it available to tests.
  // 2. add the project's depedencies as "implementation"
  // 3. remove any transitive reference of any sourceProject depenency that may have appeared
  // 4. add the project's classes to the final jar
  // Other nice effects (vs shadowJar)
  // 1. Generated poms will be correct
  // 2. Configuration is isolated to this single "sourceProject" call
  // 3. These configurations are compliant with IDEs
  project.ext.sourceProject = { Project dependencyProject ->
    def dependencyProjectClasses = dependencyProject.sourceSets.main.output
    dependencies {
      // add the dependencyProject classes as compileOnly, make it available to tests
      compileOnly dependencyProjectClasses
      testImplementation dependencyProjectClasses
      // add dependencyProject's dependencies as implementation dependencies
      implementation dependencyProject.configurations.implementation.dependencies
      if (dependencyProject.configurations.hasProperty('api')) {
        implementation dependencyProject.configurations.api.dependencies
      }
      // if we find any project dependencies that are brought in transitively, go remove them
      project.sourceProjects.each { projectToRemove ->
        project.configurations.implementation.dependencies.remove projectToRemove
      }
    }
    // keep track of all dependencyProjects for later removal
    sourceProjects += dependencyProject
    // adds dependencyProject's classes to jar (fat jar-esque)
    jar {
      from dependencyProjectClasses
    }
    // also configure the java-gradle-plugin if necessary
    if (project.hasProperty("gradlePlugin")) {
      project.tasks.pluginUnderTestMetadata.pluginClasspath.from  dependencyProjectClasses
    }
  }
  /* INCLUDED PROJECT DEPENDENCY HELPER */
}
